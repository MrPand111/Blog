<!--
 * @LastEditors: panda_liu
 * @LastEditTime: 2020-11-23 10:17:29
 * @FilePath: \Blog\浏览器\2-V8工作原理.md
 * @Description: add some description
-->
# 1 栈空间和堆空间：数据是如何存储的？

### 1.1 JavaScript语言类型和数据类型

JavaScript是一种**弱类型的**、**动态的语**言。

- 弱类型，意味着你不需要告诉JavaScript引擎这个或那个变量是什么数据类型，

- 动态，意味着你可以使用同一个变量保存不同类型的数据。

在JavaScript中有8种数据类型，分别是：

类型 | 描述
-|-
Boolean | 只有true和false
Null | 只有null
Undefined | 一个没有被赋值的变量会有个默认值undefined，变量提升时的默认值也是undefined
Number | 基于IEEE754标准的双精度64位二进制格式的值
BigInt | 新的数字类型，可以用任意精度表示整数，即使超过Number的安全整数范围限制。也可以安全地存储和操作
String | 用于表示文本数据，JS中字符串不可更改
Symbol | 符号类型是唯一的并且不可修改的，通常用来作为Object的key
Object | 在JavaScript里，对象可以被看作是一组属性的集合

### 1.2 内存空间

- **代码空间**：主要是存储可执行代码

- **栈空间**：用来存储上下文。原始类型的数据值都是直接保存在“栈”中的。

- **堆空间**：引用类型的值是存放在“堆”中的。

JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如一个函数执行结束了，JavaScript引擎需要离开当前都得执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，该函数执行上下文栈区空间全部回收。

通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型地方小数据。堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

JavaScript中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 1.3 再谈闭包

``` js
function foo() {
    var myName = "小猫咪"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("熊猫猫")
bar.getName()
console.log(bar.getName())
```

在这段代码中，当foo函数的执行上下文销毁时，由于foo函数产生了闭包，所以变量myName和test1并没有被销毁，而是保存在内存中。

要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。

1. 当JavaScript引擎执行到foo函数时，首先会编译，并创建一个空执行上下文
2. 在编译过程中，遇到内部函数setName，JavaScript引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了foo函数中的myName变量，由于的内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个闭包，于是在堆空间创建了一个“closure(foo)”的对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
3. 接着继续扫描到getName方法时，发现该函数内部还引用变量test1，于是JavaScript引擎又将test1添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了myName和test1两个变量了。
4. 由于test2并没有被内部函数引用，所以test2依然保存在调用栈中。

产生闭包的核心有两步：**第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中**。

# 2 垃圾回收：垃圾数据是如何自动回收的？

### 2.1 不通风语言的垃圾回收策略

- **手动回收**：比如C/C++。何时分配内存、何时销毁内存都是由代码控制的。

- **自动回收**：比如JavaScript、Java、python。产生的垃圾数据是由垃圾回收器来释放的。

### 2.2 栈中的数据是如何回收的

当一个函数执行结束之后，**JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文**。


### 2.3 代际假说和分代收集

**代际假说**有以下两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问

- 第二个是不死的对象，会活得更久

所以，在V8中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象**。

对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：

- 副垃圾回收器，主要负责新生代的垃圾回收

- 主垃圾回收器，主要负责老生代的垃圾回收

### 2.4 堆中垃圾回收器的工作流程

> 不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

1. 标记空间中活动对象和非活动对象。

2. 回收非活动对象所占据的内存。

3. 做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为`内存碎片`。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。

### 2.5 副垃圾回收器

主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区。

新生代中用**Scavenge算法**来处理：

1. 是把新生代空间对半划分为两个区域，一半是对象区域 ，一半是空闲区域。

2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

3. 垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

4. 完成复制后，对象区域与空闲区域进行角色翻转，对象区域和空闲互换，好处是**两块区域无限重复使用**。

5. 为了执行效率，一般新生区的空间会被设置得比较小。

6. **对象晋升策略**：经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 2.6 主垃圾回收器


主要负责老生区中的垃圾回收。老生区中的对象有两个特点：一个是对象占用空间大，另一个是对象活动时间长。

1. 采用**标记-清除（Mark-Sweep）**的算法进行垃圾回收的。

2. 标记过程：遍历一组根元素，能到达的元素称之为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。

3. 清除：清除对应位置的数据，不过多次清除算法后产生大量不连续的内存碎片。于是产生了————**标记-整理**，整理后让所有存活的对象都向一端移动。

### 2.7 全停顿

一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。

**增量标记**：为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成。


# 3 V8是如何执行一段JavaScript代码的？

### 2.1 基本概念

**编译器（Compiler）**

编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。

编译型语言的执行流程：编译器先会一次对源代码进行词法分析、语法分析，生成抽象语法树（AST） -> 然后是优化代码 -> 最后再生成处理器能够理解的机器码 -> 如果编译成功将会生成一个可执行文件；如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。

**解释器（Interpreter）**

由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。

解释型语言的解释过程：同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST） -> 它会再基于抽象语法树生成字节 -> 最后再根据字节码来执行程序、输出结果

### 2.2 V8是如何执行一段JavaScript代码的

**1.生成抽象语法树（AST）和执行上下文**

AST是代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于AST，而不是源代码。

AST是非常重要的一种数据结构，再Babel和ESLint都有应用。

生成AST需要经过两个阶段：

**第一阶段是分词（tokenize），又称为词法分析**，其作用是将一行行的源码拆解成一个个token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。

**第二阶段是解析（parse），又称为语法分析**，其作用是将上一步生成的token数据，根据语法规则转为AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

**2.生成字节码**

**字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行**。

**3.执行代码**

如果有一段第一次执行的字节码，解释器lgnition会逐条解释执行。但执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为`热点代码`，那么后台的编译器TurboFan就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
比如Java和python的虚拟机也都是基于这种技术实现的，我们把这种技术称为`即时编译（JIT）`

### 2.3 JavaScript的性能优化

应该将优化的中心聚焦在单词脚本的执行时间和脚本的网络下载上，主要关注以下三点：
1. 提升单次脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程；
3. 减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。 