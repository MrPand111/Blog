# 1 浏览器缓存概述

## 1.1 缓存的好处

- 缓存服务器压力（不用每次去请求资源）

- 提升性能（打开本地资源）

- 减少带宽消耗

## 1.2 缓存的分类

- **私有缓存**：只能用于单独用户，常见的是浏览器缓存

- **共享缓存**：能被多个用户使用的缓存，也就是那些能被各级代理的缓存

# 2 浏览器的缓存策略

浏览器对于缓存的处理是根据第一次请求资源时返回的**响应头**来确定的。

根据响应头,浏览器缓存策略一般分为三种：**强缓存**,**协商缓存**和**启发式缓存**。

## 2.1 浏览器常见字段和指令

- **expires**: 告知客户端资源缓存失效的绝对时间
- **last-modified**: 资源最后一次修改的时间
- **Etag**: 文件的特殊标识
- **cache-control**:告诉客户端或是服务器如何处理缓存。
- **private**: cache-control里的响应指令.表示客户端可以缓存
- **public**: cache-control里的响应指令.表示客户端和代理服务器都可缓存.如果没有明确指定private，则默认为public。
- **no-cache**: cache-control里的指令.表示需要可以缓存，但每次用应该去向服务器验证缓存是否可用
- **no-store**: cache-control字段里的指令.表示所有内容都不会缓存，强制缓存，对比缓存都不会触发.
- **max-age=xxx**: cache-control字段里的指令.表示缓存的内容将在 xxx 秒后失效

## 2.2 强缓存

> 给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。

**强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制**。

**expires**

expires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。

**用法：**

它描述的是一个**绝对时间**,用GMT格式的字符串表示

``` js
Expires: Wed Feb 20 2019 11:25:41 GMT
```

**弊端：**

Expires返回的是**服务器的时间**，但**判断的时候用的却是客户端的时间**，这就导致Expires很被动，因为**用户有可能改变客户端的时间**，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。

**cache-control: max-age**

为了解决expires存在的问题，Http1.1版本中提出了cache-control:max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是**max-age设置的是相对缓存时间开始往后的多少秒**，因此不再受日期不准确情况的影响。

**用法：**

``` js
// 表示资源会在666秒后过期，需要再次请求
Cache-control: max-age=666
```

**强缓存在浏览器上的表现**

Chrome浏览器状态码表现为:`200 (from disk cache)`或是`200 OK (from memory cache`。

> 说明：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，磁盘的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。

## 2.3 协商缓存

协商缓存解决了无法及时获取更新资源的问题。它利用下面会讲到的两组字段,对资源做标识.然后由服务器做分析，**如果资源未更新，则返回304状态码**。那么浏览器则会从缓存中读取资源，否则重新请求资源。


协商缓存是利用的是【**Last-Modified，If-Modified-Since**】和【**ETag、If-None-Match**】这两对Header来管理的。

**Last-Modified与If-Modified-Since**

1. 浏览器第一次向服务器请求资源，服务器在返回这个资源的同时，**在response的header加上Last-Modified**，这个header表示这个资源在服务器上的最后修改时间：`Last-Modified: Wed Feb 20 2019 14:08:32 GMT`

2. 浏览器之后再向服务器请求这个资源时，**在request的header中加上If-Modified-Since**，这个header的值就是上一次请求时返回的Last-Modified的值。

3. 服务器再次收到资源请求时，**根据浏览器传过来If-Modified-Since**和资源在服务器上的最后修改时间判断是否有变化，**如果没有变化则返回304 Not Modified**，**但是不会返回资源内容**；如果有变化,返回200，就正常返回资源内容。

> 当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变。

4. 浏览器收到304的响应后，就会从缓存中加载资源。

5. 浏览器收到200的响应后，则从服务器加载新资源时，**Last-Modified Header在重新加载的时候会被更新**，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。

**弊端**

【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，但是**它们是以秒为单位进行更新，如果小于该单位高频进行更新的话，则不适合采用该方法**。

**ETag与If-None-Match**

1. 浏览器第一次请求服务器一个资源，服务器在返回这个资源的同时，在response的header加上ETag，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，`ETag: pandaliu123456`。只要资源有变化，这个串就不同。

2. 浏览器再次跟服务器请求这个资源时，**在request的header上加上If-None-Match**，这个header的值就是上一次请求时返回的ETag的值.

3. 服务器再次收到资源请求时，**根据浏览器传过来If-None-Match**然后再**根据资源生成一个新的ETag**，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，**由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化**。

4. 浏览器收到304的响应后，就会从缓存中加载资源。

5. 浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。

**优劣势**

- ETag相对于Last-Modified也有其优势，**可以更加准确的判断文件内容是否被修改**， 从而在实际操作中实用程度也更高,

- 但缺点也很明显,**由于需要对资源进行生成标识，性能方面就势必有所牺牲**。

> 注意：先检查Cache-Control,如果为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发!!!

