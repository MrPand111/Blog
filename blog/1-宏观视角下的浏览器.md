---
title: 1-宏观视角下的浏览器
date: 2020-05-18 14:59:12
tags: [JavaScript]
categories: [浏览器工作实践原理]
---

# 01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？

## 进程和线程

1. **一个进程就是一个程序的运行实例**：启动一个程序时，操作系统创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。

2. 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

3. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。

4. 线程之间共享进程中的数据。

5. 当一个进程关闭之后，操作系统会回收进程所占用的内存。

6. 进程之间的内容相互隔离。

## 早期浏览器问题

1. **不稳定**：插件、渲染引擎模块
2. **不流畅**：无限循环脚本、页面内存泄漏
3. **不安全**：恶意插件、脚本通过浏览器漏洞获取系统权限

## 目前多进程架构

- **浏览器进程**：界面显示、用户交互、子进程管理、存储
- **渲染进程**：排版引擎Blink和JS引擎V8。运行再沙箱模式下
- **GPU进程**：实现3D效果
- **网络进程**：负责页面网络资源加载
- **插件进程**：负责插件的运行

# 02 | TCP协议：如何保证页面文件能被完整送达浏览器？

## 数据包

1. 计算机的地址就成为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息

## UDP：把数据包送达应用程序

- 用户数据包协议（User Datagram Protocol）。最重要的信息是**端口号**。**IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。**

- UDP不能保证数据可靠性，但是传输速度却非常快。

## TCP：把数据完整地送达应用程序

- 传输控制协议（Transmission Control Protocol）。是一种面向连接的、可靠的、基于字节流的传输层通信协议。

- **完整的TCP连接过程**：
    1. 建立连接阶段。三次握手
    2. 传输数据阶段。接收端需要对每个数据包进行确认操作
    3. 断开连接

> 无论是UDP还是TCP，都像是从一个码头（浏览器）装货物（头、数据包），运输到另一个码头（服务器）卸货物

# 03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？

## 浏览器端发起HTTP请求流程

1. 构建请求

    ``` 
    GET /index.html HTTP1.1
    ```

2. 查找缓存

    在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。**浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术**

3. 准备IP地址和端口号

    - **HTTP的内容是通过TCP的传输数据阶段来实现的**
    - DNS（域名系统）：域名和IP地址间的映射关系
    - DNS数据缓存服务：域名解析后浏览器缓存解析结果

4. 等待TCP队列

    Chrome中同一个域名多于6个的TCP连接会进入排队状态

5. 建立TCP连接

6. 发送HTTP请求

    - 请求行、请求头（GET）
    - 请求体（POST）

## 服务端处理HTTP请求流程

1. 返回请求

    - 响应行、响应头、响应体
    - 状态码

2. 断开连接

    关闭TCP连接。可以通过*connection：Keep-Alive*保持打开状态，**保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度**

3. 重定向

    - 状态码：301
    - 请求头中Location: 重定向的地址

## 为什么很多站点第二次打开速度会很快？

    - DNS缓存和页面缓存
    - 通过响应头中的Cache-Control字段来设置是否缓存该资源

## 登录状态是如何保持的？

    用户登录后，后台生成cookie，写入响应头的Set-Cookie中。浏览器接收后保存到本地，用户再次访问时会将数据写入请求头中的Cookie。服务器收到请求后会查询后台判断该用户是已登录状态，返回对应的信息

# 04 | 导航流程：从输入URL到页面展示，这中间发生了什么？

**整个过程需要各大进程之间的配合**

## 1.用户输入

判断地址框输入的关键字是**搜索内容**，还是**请求的URL**。组装协议。回车后，浏览器进入加载状态

## 2.URL请求过程

- 页面资源请求过程：浏览器进程通过进程间通信（IPC）把URL请求发送到网络进程
- 网络进程会查找本地缓存，如果有直接返回，没有则网络请求：DNS解析（HTTPS还需建立TLS连接）、TCP/IP建立连接、发送请求、服务器返回响应头给网络进程：
    1. **重定向**：如果状态码301、302，，重定向到Location字段中的地址，再次发送网络请求；如果状态码200，表示浏览器可以继续处理该请求
    2. **响应数据类型处理**：**Content-Type字段告诉浏览器服务器返回的响应体数据是什么类型**。根据类型，浏览器会判断如何执行接下来的流程

## 3.准备渲染进程

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程

## 4.提交文档

“文档”指URL请求的响应体数据
- 浏览器进程发出提交文档，渲染进程接收到该消息后，会建立和网络进程的传输数据**管道**
- 文档传输完成后，渲染进程返回**确认提交**给浏览器进程
- 浏览器进程收到确认提交后，会**更新浏览器界面状态**

## 5.渲染阶段

文档被提交，渲染进程便开始页面解析和子资源加载

# 05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的

渲染模块被划分为很多子阶段，这样的一个处理流程叫做**渲染流水线**

在每个子阶段都有输入的内容、处理过程、输出内容

## 构建DOM树

## 样式计算

1. 把CSS转换为浏览器能给理解的结构：当渲染引擎接收CSS文本时，会将CSS文本转换为浏览器可以理解的结构————styleSheets

2. 转换样式表中的属性值，使其标准化（比如：em、blue、bold）

3. 计算出DOM树中每个节点的具体样式：继承+层叠

## 布局阶段

计算出DOM树中可见元素的几何位置。

1. 创建布局树：显示之前，额外地构建一棵只包含可见元素布局树
2. 布局计算：计算布局树节点的坐标位置

# 06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的

## 分层

- 并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层
- 拥有层叠上下文属性的元素会被提升为单独的一层
- 需要剪裁的地方也被创建为图层

## 图层绘制

拆分为很多小的**绘制指令**

## 栅格化操作

合成线程会按照视口附近的图来优先生成位图，实际生成位图的操作是由栅格化来执行的。**栅格化，是指将图块转换为位图**。

## 合成和显示

光栅化后合成线程生成"DrawQuad"命令提交给浏览器，将其页面内容绘制到内存，最终显示在屏幕上

## 相关概念

1. **重排：更新了元素的几何属性**：类似于*div.style.height=xxx*。重拍需要更新完整的渲染流水线，所以开销最大

2. **重绘：更新元素的绘制属性**：类似于*div.style.background=xxx*。重绘省去了布局和分层阶段，所以执行效率高一点

3. **直接合成阶段**：类似于*transform：translate(xxx,xxx)*，效率最高

## 总结

1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的
样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。 5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。