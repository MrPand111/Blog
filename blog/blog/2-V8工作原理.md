<!--
 * @LastEditors: panda_liu
 * @LastEditTime: 2020-09-01 09:01:24
 * @FilePath: \yunniubaoc:\Users\23163\Desktop\web\Blog\blog\2-V8工作原理.md
 * @Description: add some description
-->
# 1 栈空间和堆空间：数据是如何存储的？

### 1.1 JavaScript语言类型和数据类型

JavaScript是一种**弱类型的**、**动态的语**言。

- 弱类型，意味着你不需要告诉JavaScript引擎这个或那个变量是什么数据类型，

- 动态，意味着你可以使用同一个变量保存不同类型的数据。

在JavaScript中有8种数据类型，分别是：

类型 | 描述
-|-
Boolean | 只有true和false
Null | 只有null
Undefined | 一个没有被赋值的变量会有个默认值undefined，变量提升时的默认值也是undefined
Number | 基于IEEE754标准的双精度64位二进制格式的值
BigInt | 新的数字类型，可以用任意精度表示整数，即使超过Number的安全整数范围限制。也可以安全地存储和操作
String | 用于表示文本数据，JS中字符串不可更改
Symbol | 符号类型是唯一的并且不可修改的，通常用来作为Object的key
Object | 在JavaScript里，对象可以被看作是一组属性的集合

### 1.2 内存空间

- **代码空间**：主要是存储可执行代码

- **栈空间**：用来存储上下文。原始类型的数据值都是直接保存在“栈”中的。

- **堆空间**：引用类型的值是存放在“堆”中的。

JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如一个函数执行结束了，JavaScript引擎需要离开当前都得执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，该函数执行上下文栈区空间全部回收。

通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型地方小数据。堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

JavaScript中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 1.3 再谈闭包

``` js
function foo() {
    var myName = "小猫咪"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("熊猫猫")
bar.getName()
console.log(bar.getName())
```

在这段代码中，当foo函数的执行上下文销毁时，由于foo函数产生了闭包，所以变量myName和test1并没有被销毁，而是保存在内存中。

要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。

1. 当JavaScript引擎执行到foo函数时，首先会编译，并创建一个空执行上下文
2. 在编译过程中，遇到内部函数setName，JavaScript引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了foo函数中的myName变量，由于的内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个闭包，于是在堆空间创建了一个“closure(foo)”的对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
3. 接着继续扫描到getName方法时，发现该函数内部还引用变量test1，于是JavaScript引擎又将test1添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了myName和test1两个变量了。
4. 由于test2并没有被内部函数引用，所以test2依然保存在调用栈中。

产生闭包的核心有两步：**第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中**。

# 2 垃圾回收：垃圾数据是如何自动回收的？

### 2.1 不通风语言的垃圾回收策略

- **手动回收**：比如C/C++。何时分配内存、何时销毁内存都是由代码控制的。

- **自动回收**：比如JavaScript、Java、python。产生的垃圾数据是由垃圾回收器来释放的。

### 2.2 栈中的数据是如何回收的

当一个函数执行结束之后，**JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文**。


### 2.3 代际假说和分代收集

**代际假说**有以下两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问

- 第二个是不死的对象，会活得更久

所以，在V8中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象**。

对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：

- 副垃圾回收器，主要负责新生代的垃圾回收

- 主垃圾回收器，主要负责老生代的垃圾回收

### 2.4 堆中垃圾回收器的工作流程

> 不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

1. 标记空间中活动对象和非活动对象。

2. 回收非活动对象所占据的内存。

3. 做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为`内存碎片`。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。

### 2.5 副垃圾回收器

主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区。

新生代中用**Scavenge算法**来处理：

1. 是把新生代空间对半划分为两个区域，一半是对象区域 ，一半是空闲区域。

2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

3. 垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

4. 完成复制后，对象区域与空闲区域进行角色翻转，对象区域和空闲互换，好处是**两块区域无限重复使用**。

5. 为了执行效率，一般新生区的空间会被设置得比较小。

6. **对象晋升策略**：经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 2.6 主垃圾回收器


主要负责老生区中的垃圾回收。老生区中的对象有两个特点：一个是对象占用空间大，另一个是对象活动时间长。

1. 采用**标记-清除（Mark-Sweep）**的算法进行垃圾回收的。

2. 标记过程：遍历一组根元素，能到达的元素称之为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。

3. 清除：清除对应位置的数据，不过多次清除算法后产生大量不连续的内存碎片。于是产生了————**标记-整理**，整理后让所有存活的对象都向一端移动。

### 2.7 全停顿

一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。

**增量标记**：为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成。