<!--
 * @LastEditors: panda_liu
 * @LastEditTime: 2020-08-29 17:44:17
 * @FilePath: \yunniubaoc:\Users\23163\Desktop\web\Blog\blog\2-V8工作原理.md
 * @Description: add some description
-->
# 1 栈空间和堆空间：数据是如何存储的？

### 1.1 JavaScript语言类型和数据类型

JavaScript是一种**弱类型的**、**动态的语**言。

- 弱类型，意味着你不需要告诉JavaScript引擎这个或那个变量是什么数据类型，

- 动态，意味着你可以使用同一个变量保存不同类型的数据。

在JavaScript中有8种数据类型，分别是：

类型 | 描述
-|-
Boolean | 只有true和false
Null | 只有null
Undefined | 一个没有被赋值的变量会有个默认值undefined，变量提升时的默认值也是undefined
Number | 基于IEEE754标准的双精度64位二进制格式的值
BigInt | 新的数字类型，可以用任意精度表示整数，即使超过Number的安全整数范围限制。也可以安全地存储和操作
String | 用于表示文本数据，JS中字符串不可更改
Symbol | 符号类型是唯一的并且不可修改的，通常用来作为Object的key
Object | 在JavaScript里，对象可以被看作是一组属性的集合

### 1.2 内存空间ying

- **代码空间**：主要是存储可执行代码

- **栈空间**：用来存储上下文。原始类型的数据值都是直接保存在“栈”中的。

- **堆空间**：引用类型的值是存放在“堆”中的。

JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如一个函数执行结束了，JavaScript引擎需要离开当前都得执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，该函数执行上下文栈区空间全部回收。

通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型地方小数据。堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

JavaScript中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 1.3 再谈闭包

``` js
function foo() {
    var myName = "小猫咪"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("熊猫猫")
bar.getName()
console.log(bar.getName())
```

在这段代码中，当foo函数的执行上下文销毁时，由于foo函数产生了闭包，所以变量myName和test1并没有被销毁，而是保存在内存中。

要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。

1. 当JavaScript引擎执行到foo函数时，首先会编译，并创建一个空执行上下文
2. 在编译过程中，遇到内部函数setName，JavaScript引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了foo函数中的myName变量，由于的内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个闭包，于是在堆空间创建了一个“closure(foo)”的对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
3. 接着继续扫描到getName方法时，发现该函数内部还引用变量test1，于是JavaScript引擎又将test1添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了myName和test1两个变量了。
4. 由于test2并没有被内部函数引用，所以test2依然保存在调用栈中。

产生闭包的核心有两步：**第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中**。