## 1. http和https的基本概念

**http**：超文本传输协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

**https**：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层。

## 2. https握手过程

1. 客户端发起请求（ClientHello）：客户端向服务端发起加密通信的请求
2. 服务器回应（ServerHello）：服务器收到客户端请求后，确认加密通信协议版本是否一致，如果版本一致则返回服务器证书，否则关闭加密通信
3. 客户端回应：客户端收到服务器回应后，客户端首先验证证书是否有效。如果证书失效，则会给访问者一个警示，由其决定是否继续连接。如果证书没失效，则使用证书中的公钥加密一个随机数(pre-master key)返回给服务器，同时返回客户端握手结束通知。
4. 服务器的最后回应：服务器收到客户端发来的pre-master key后，计算生成本次会话的“会话密钥”，向客户端发送服务器握手结束通知。

至此，握手阶段结束，接下来加密通信。

## 3. tcp三次握手概括

简易版：

- 第一次握手：S只可以确认自己可以接受C发送的报文段
- 第二次握手：C可以确认S收到了自己发送的报文段，并可以确认自己可以接受S发送的报文段
- 第三次握手：S可以确认C收到了自己发送的报文段

正式版：

- 第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的 随机数。它代表的是客户端数据的初始序号。

- 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向 客户端发送 SYN ACK 报文段，报文段的首部中SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认， 同时序号字段是服器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加 一。

- 第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务 器端的报文段的确认。第三次握手可以在报文段中携带数据。

## 4. fetch发送两次请求的原因

fetch发送post请求，总是发送两次，第一次状态码204，第二次200
原因是因为第一次fetch发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求

## 5. 常用状态码

- 2XX (Success)

  - 200 OK
  > 表示从客户端发来的请求在服务器被正常处理了

  - 204 No Content
  > 代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分

   - 206 Partical Content
   > 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求响应报文中包含由Content-Range指定范围的实体内容

- 3XX (Redirection)

  - 301 Moved Permanently
  > 永久性重定向。会更新书签

  - 302 Found
  > 临时性重定向。资源不是被永久移动

  - 303 See Other
  > 表示由于请求对应的资源存在着另一个url，应使用GET方法定向获取请求的资源

  - 304 Not Modified
  > 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件。304状态码返回时，不包含任何响应的主体部分

  - 307 Temporary Redirect
  > 临时重定向。禁止POST变成GET

- 4XX (Client Error)

  - 400 Bad Request
  > 表示报文中存在语法错误。需要修改内容后再次发送。浏览器会像200 OK一样对待该状态码

  - 401 Unauthorized
  > 表示发送的请求需要由通过HTTP认证的认证信息。如果之前进行过1次请求，表示用户认证失败

  - 403 Forbidden
  > 表明对请求资源的访问被服务器拒绝了。可能未获得文件系统的访问授权、访问权限出现问题

  - 404 Not Found
  > 表明服务器上无法找到请求的资源。也可以在服务器端拒绝请求且不想说明理由时使用

  - 405 Method Not Allowed
  > 表明客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。客户端可以通过Options方法查看允许的访问方法

- 5XX (Server Error)

  - 500 Internal Server Error
  > 表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时的故障

  - 502 Bad Gateway
  > 表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的

  - 503 Service Unavailable
  > 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

## 6. 从地址栏里输入一个url，到这个页面渲染出来。中间会发生什么？

1. 判断地址栏的关键字是搜索内容还是url
2. 如果是url：浏览器进程通过通信把url请求发送给网络进程
3. 网络进程会查询本地缓存，如果有直接返回，没有则网络请求
4. 请求过程为DNS解析、TCP/IP建立连接、发送请求、服务器响应返回html
5. 渲染进程将HTML转化成DOM树，构建过程中遇到js脚本就停止构建去执行代码
6. 将CSS样式构建为一个CSSOM树，然后和DOM树合并为渲染树
7. 合成线程对渲染树进行分层、图层绘制、光栅化操作后发送DrawQuad给浏览器进程
8. 浏览器根据DrawQuad消息生成页面显示在显示器上

## 7. TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的
2. TCP连接传送的数据无差错、不丢失；UDP不保证可靠交付
3. TCP面向字节流，UDP面向报文
4. TCP只能1对1的，UDP支持1对1，1对多
5. TCP的首部为20字节，UDP只有8字节

## 8. OSI七层模型

OSI参考模型 | 各层的解释
-|-
应用层 | 为应用程序提供服务
表示层 | 数据格式转化、数据加密
会话层 | 建立、管理和维护会话
传输层 | 建立、管理和维护端到端的连接
网络层 | IP地址及路由选择
数据链路层 | 提供介质访问和链路管理
物理层 | 物理层

## 9. TCP/IP五层模型

| TCP/IP五层模型 | 协议 |
|-|-|
| 应用层 | HTTP、FTP、SMTP |
| 传输层 | TCP、UDP、RTP、RSVP |
| 网络层 | IP、ICMP |
| 数据链路层 | Wi-Fi、PPP |
| 物理层 |  |


## 10. HTTP1.1 HTTP/2 and HTTP/3

**HTTP/1.1**

- **长连接**： HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

- **缓存信息**：    在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略

- **节约宽带**

**HTTP/2**

- **二进制协议**：HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"。
- **多路复用**：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就免了"队头堵塞"的问题。
- **数据流**：HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。
- **头信息压缩**： 一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张**头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引 号，这样就能提高速度了。

**HTTP/3**

由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能。